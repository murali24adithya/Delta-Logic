	\section{From VC to Delta Logic}
Let us consider the following Hoare Triple: ($\alpha_{pre}$, $T$, $\alpha_{post}$) such that $\alpha_{pre}$ and $\alpha_{post}$ are FO+\textit{lfp} formulae. The program manipulates pointers and data fields, which we model using unary functions. We can then write $\alpha_{pre}$ over a tuple of variables, fields, recursively defined functions and recursively defined predicates $(X_1, P_1, G_1, R_1)$, and $\alpha_{post}$ over a tuple $(X_2, P_2, G_2, R_2)$ such that $\forall{} f \in{} P_1,\, \exists{}! f' \in{} P_2$ and vice-versa, and for every definition $g \in{} G_1$, there exists a $g' \in{} G_2$ such that $g' = g[P_2/P_1]$ is a substitution of $f'$ for the corresponding $f$ in the definition of $g$, and similarly for recursively defined predicates. We also require that $\, X_1 \cap{} X_2 = P_1 \cap{} P_2 = G_1 \cap{} G_2 = R_1 \cap{} R_2 = \emptyset{}$, i.e that the two do not share any names of variables (with appropriate sorts), pointer/data fields, recursively defined functions or recursively defined predicates, respectively. Intuitively, this is used to distinguish the state of the pointer/data fields in the universe after the execution of the program, and the recursively defined functions/predicates that depend on them. Of course, the formulae can refer in common to other functions and relations (say, such as those modelling arithmetic relations and functions). \\\

We can also write $T$, the formula describing the program transformation, over $X_1 \cup{} X_2 \cup{} X_{tmp}$ and $P_1 \cup{} P_2$ such that $X_1 \cup{} X_2 \cup{} X_{tmp} \subseteq{} \Delta$, where $T = T_1 \land{} T_2$ can be written as a conjuction of:\\
\begin{itemize}
\item A quantifier-free formula $T_1$ such that any subterm of the form $f(t)$ for some $f \in{} P_1 \cup{} P_2$ and some term $t$ must have $t = v$ for some $v \in{} \Delta{}$ (this is to ensure that the pointer and data fields are only referenced at variables in $\Delta{}$).\\
\item ;and a formula $T_2$ that conjuncts over formulae of the form: $\left(\forall{}z.\,z\notin{}\Delta{},\, f'(z) = f(z) \right)$ for all $f \in{} P_1$, where $f'$ is the corresponding symbol in $P_2$ (this describes that the pointer and data fields are changed only on variables in $\Delta$). \\
\end{itemize} 
This is possible since the program changes the values of the data and pointer fields on elements only within $\Delta$, and the values of the variables in the state resulting after the program execution can be written as expressions of the values in the state before, with only a finite number of temporary variables.\\\

It is clear that the VC that captures the goven Hoare Triple will be $\alpha_{pre} \land{} T \land{} \neg{} \alpha_{post}$, which by the above is a formula in FO+\textit{lfp} within our given signature. From theorem \ref{separability}, we have that an FO+\textit{lfp} formula can be written equivalently as a boolean combination of context-logic formulae and quantifier-free formulae that refer only to variables in $\Delta$ and restrict the domain of the functions to $\Delta$, so-called 'delta' formulae. Therefore, $\alpha_{pre}$ and $\alpha_{post}$ can be rewritten to equivalent formulae that are Boolean combinations of context formulae and delta formulae.\\
However, from the theorem, we will also see in particular that the resursive definitions of functions and predicates in $\alpha_{post}$ use functions from $P_2$ only in clauses defining their values over $\Delta{}^{c}$, which, from the last conjunct of each clause in $T_2$, can be replaced with functions in $P_1$ since the pointer and data fields of variables not in $\Delta$ are unaltered by the program. Then, we also remove the last conjunct of every clause in $T_2$ since the symbols in $P_2$ are no longer referred to anywhere else on an argument not in $\Delta{}$.\\\

Therefore, the VC can be written equivalently as a Boolean combination of context formulae that refer only to recursive definitions one set of pointer and data fields, capturing the context of the program's execution correctly, and delta formulae without any subterms containing recursive predicates or functions that capture how pointer and data fields in (locations interpreted over) $\Delta$ are changed, as well as communicating the effects of those changes upon the valuations of these predicates/functions to the unchanging context of the program execution. Satisfiability of the VC then becomes the meaningful question of asking independently for a model of a context, a prior state and a resulting state (with a common valuation for finitely many shared first-order variables), such the context when applied over a model of the prior state satisfies the precondition, and applied over a model of the resulting state falsifies the postcondition. 