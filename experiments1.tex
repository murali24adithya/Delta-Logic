\section{Implementation and evaluation of decision procedure for LM}
In this section we detail the results of implementing the above-mentioned decision procedure for $LM[ls, hls, rank, len, mskeys, min, max, sorted]$. Encoded and solved in the Z3 framework, this implementation abstracts the delta-logic VC to one with the function $T$ as defined above that collapses list segments and represents the heaplets,  multisets of keys  therein symbolically. We experimented our technique on the programs mentioned in table \ref{experiments}. The programs and the program transformations thereof were implemented manually. The specifications for the programs were the strongest possible that could be expressed in our logic. For example, the program \textit{copyall} copies a given list pointed to by $x$ into one pointed to by $y$, and has the precondition that $x$ points to a list, and the postcondition that $y$ points to a list whose multiset of keys is the same as that of $x$ but whose heaplet is disjoint, and that at the end of the program neither the heaplet nor the multiset of keys of the list pointed to by $x$ have changed.\\
Folllowing are the main points of observation:
\begin{itemize}
\item{} One significant difference from the VC generated by the formal decision procedure above is the merging of $Dist$ and $rank$ into a single uninterpreted function $d$, where the if the function/ predicate is propagated on a valid model, the value of $d$ increases along the chain starting from $0$ at the terminal point of the segment.

\item{}We also represent keys as integers and not a type in their own right as was given in the description of the syntax of $LM$. Some optimisation would be gained from implementing that distinction.   

\item{}Concering the representation of the measures and constraints between them:
	\begin{itemize}
 	\item{} we make the choice of representing not exponentially many extra keys in each collapsible segment, but one extra key apart from those mentioned in the formula or those of terms mentioned in the formula since we do not require intersections of multisets of keys in any of our programs apart from checking for the sub-multiset relation. This proves to be a good optimisation, and is sufficient to prove not just the examples listed here, but a fair number of other common programs that manipulate lists. 
	\item{} We also do not specify the restriction that the length of each collapsible segment is equal to the cardinality of its heaplet since it is not possible to express cardinality for arbitrary sets without a quantifier using the atoms in Z3. The argument is that this is very close to our decision procedure, covers a large number of cases and is faster since it makes simplifying assumptions. If a VC fails to pass in this implementation, then one can choose to feed it into an implementation that represents the sets and cardinalities using BAPA. 
	\item{} Similarly, we do not implement the restriction that the cardinality of the multiset of keys must be equal to the length of the collapsible segment. Moreover, the keys bearing minimum and maximum value on each segment if different from the keys mentioned in the formula cannot specify conditions on their multiplicity in the segment.
	\end{itemize}
\item{} Lastly a few parts, such as the automatic inference of the number of variables needed or the encoding of a program in a chosen syntax to its formula representing the transformation remain to be automated. The interplay of several measures may also be optimised in restriction and representation, and this would require a more detailed implementation that we leave for future work.
\end{itemize}

\begin{longtable}{| l| c| c|} 
\hline
 program & \#VCs & time(s) \\ 
\hline
append(x: list, y: list) & 4 & foo \\ 
copyall(x: list) & 4 & foo \\ 
detect\_cycle(x: list) & 6 & foo \\ 
deleteall(x: list, k: key) & 5 & foo \\ 
find(x: list, k: key) & 3 & foo \\ 
insert(x: list, k: key) & 4 & foo \\ 
insert\_front(x: list, k: key) & 1 & foo\\ 
insert\_back(x: list, k: key) & 4 & foo\\ 
reverse(x: list) & 3 & foo\\ 
\hline
sorted\_append(x: list, y: list) & 4 & foo \\ 
sorted\_deleteall(x: list, k: key) & 5 & foo \\ 
sorted\_insert(x: list, k: key) & 4 & foo \\ 
sorted\_reverse(x: list) & 3 & foo \\ 
sorted\_merge(x: list, y: list) & 8 & foo \\ 
\hline
\caption{Decision procedure for LM: experimental results} % needs to go inside longtable environment
\label{experiments}
\end{longtable}